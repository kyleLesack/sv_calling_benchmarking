import argparse
import os
from collections import defaultdict
import random

parser = argparse.ArgumentParser()
parser.add_argument("input_bed", help="bed file with clustered reads. Created from a matching vcf file.")
parser.add_argument("sv_caller", help="variant caller used to create vcf file. Use assemblytics, fusorsv, mumandco, pbsv, sniffles, or svim")
args = parser.parse_args()

# Get clusters of overlapping SV calls (generated by bedtools) and store them in a dict
def get_clusters(variants,caller):
	cluster_dict = defaultdict(list)

	if caller == "assembly":
		for line in variants:
			line_split = line.split()
			variant_name = line_split[3]
			cluster_number = line_split[4]
			cluster_dict[cluster_number].append(line)

	elif caller == "fusorsv":
		for line in variants:
			line_split = line.split()
			cluster_number = line_split[4]
			cluster_dict[cluster_number].append(line)

	elif caller == "sniffles" or caller == "pbsv":
		for line in variants:
			line_split = line.split()
			cluster_number = line_split[6]
			cluster_dict[cluster_number].append(line)

	else:
		for line in variants:
			line_split = line.split()
			cluster_number = line_split[5]
			cluster_dict[cluster_number].append(line)

	return(cluster_dict)

# Separate variant call dict into sv call clusters with one member or multiple members
def resolve_cluster(sv_calls,caller):
	best_support_value = 0 # Store the value for the best supported sv call. Metric depends on caller.
	best_supported_call = 0 # Stores the highest support call from the sv calls list.
	best_support_value_tied = False
	current_call = 0
	tied_calls = set() # Calls sometimes have the same value for the support metric used. A set of tied calls is created to randomly select a call from if tied.

	if caller == "pbsv":
		precise_call = False
		for line in sv_calls:
			cnv_call = False
			sv_call_split = line.split("\t")
			call_precision = sv_call_split[3]
			call_name = sv_call_split[4]

			if "CNV" in call_name:
				cnv_call = True

			sv_name = sv_call_split[4]
			if precise_call == False and call_precision == "PRECISE":
				# cnv calls don't give read support
				if not cnv_call:
					sv_read_support = sv_call_split[5].split(":")[1]
					sv_read_support = sv_read_support.split(",")[1]
					sv_read_support = int(sv_read_support)
					best_support_value = sv_read_support

				precise_call = True
				best_support_value_tied = False
				tied_calls = set()
				best_supported_call = current_call

			elif precise_call == True and call_precision == "PRECISE":
				# Check if variant type is a CNV. pbsv doesn't give any support data to choose the best supported cnv call when there is overlap.
				if "CNV" in sv_name:
					best_support_value_tied = True
					tied_calls.add(best_supported_call)
					tied_calls.add(current_call)

				else:
					# I'm using the AD entry reported by pbsv. It's reported as 2 comma separated numbers. The 1st is the ref allele depth, the 2nd is the number of reads supporting the sv
					sv_read_support = sv_call_split[5].split(":")[1]
					sv_read_support = sv_read_support.split(",")[1]
					sv_read_support = int(sv_read_support)

					if sv_read_support == best_support_value:
						best_support_value_tied = True
						tied_calls.add(best_supported_call)
						tied_calls.add(current_call)

					elif sv_read_support > best_support_value:
						tied_calls = set()
						best_support_value_tied = False
						best_support_value = sv_read_support
						best_supported_call = current_call

			else:

				# Check if variant type is a CNV. pbsv doesn't give any support data to choose the best supported cnv call when there is overlap.
				if "CNV" in sv_name:
					best_support_value_tied = True
					tied_calls.add(best_supported_call)
					tied_calls.add(current_call)

				else:
					# I'm using the AD entry reported by pbsv. It's reported as 2 comma separated numbers. The 1st is the ref allele depth, the 2nd is the number of reads supporting the sv
					sv_read_support = sv_call_split[5].split(":")[1]
					sv_read_support = sv_read_support.split(",")[1]
					sv_read_support = int(sv_read_support)

					if sv_read_support == best_support_value:
						best_support_value_tied = True
						tied_calls.add(best_supported_call)
						tied_calls.add(current_call)
					elif sv_read_support > best_support_value:
						tied_calls = set()
						best_support_value_tied = False
						best_support_value = sv_read_support
						best_supported_call = current_call

			current_call += 1

		# If multiple calls have the best support value, chose one randonly
		if best_support_value_tied:
			random_line = random.sample(list(tied_calls),1)
			best_call_line = sv_calls[random_line[0]]

		else:
			best_call_line = sv_calls[best_supported_call]

	elif caller == "sniffles":
		precise_call = False
		for line in sv_calls:

			sv_call_split = line.split("\t")
			call_precision = sv_call_split[3]
			# I'm using the sniffles DV value, which is the number of reads supporting the variant
			sv_read_support = sv_call_split[5].split(":")[3]
			sv_read_support = int(sv_read_support)

			# Precise calls are selected over imprecise calls
			if precise_call == False and call_precision == "PRECISE":
				precise_call = True
				best_support_value_tied = False
				tied_calls = set()
				best_support_value = sv_read_support
				best_supported_call = current_call

			elif precise_call == True and call_precision == "PRECISE":
				if sv_read_support == best_support_value:
					best_support_value_tied = True
					tied_calls.add(best_supported_call)
					tied_calls.add(current_call)

				elif sv_read_support > best_support_value:
					tied_calls = set()
					best_support_value_tied = False
					best_support_value = sv_read_support
					best_supported_call = current_call

			else:
				if sv_read_support == best_support_value:
					best_support_value_tied = True
					tied_calls.add(best_supported_call)
					tied_calls.add(current_call)

				elif sv_read_support > best_support_value:
					tied_calls = set()
					best_support_value_tied = False
					best_support_value = sv_read_support
					best_supported_call = current_call
			current_call += 1

		if best_support_value_tied:
			random_line = random.sample(list(tied_calls),1)
			best_call_line = sv_calls[random_line[0]]
		else:
			best_call_line = sv_calls[best_supported_call]

	elif caller == "svim":
		for line in sv_calls:
			sv_call_split = line.split("\t")

			# I'm using the svim QUAL value. This is calculated by svim
			sv_read_support = sv_call_split[4].split(":")[1]
			sv_read_support = int(sv_read_support)

			if sv_read_support == best_support_value:
				best_support_value_tied = True
				tied_calls.add(best_supported_call)
				tied_calls.add(current_call)

			elif sv_read_support > best_support_value:
				tied_calls = set()
				best_support_value_tied = False
				best_support_value = sv_read_support
				best_supported_call = current_call
			current_call += 1

		if best_support_value_tied:
			random_line = random.sample(list(tied_calls),1)
			best_call_line = sv_calls[random_line[0]]

		else:
			best_call_line = sv_calls[best_supported_call]

	# Assembly based methods didn't have any metric that gives the support for a given call
	elif caller == "assembly":
		for line in sv_calls:
			best_call_line = random.sample(sv_calls,1)[0]

	return(best_call_line)

# Take the clustered call dict and return the bedfile lines to write to disk
def get_calls(cluster_dict,caller):
	bed_lines = []
	for cluster_number, variant_line in cluster_dict.items():
		if len(variant_line) == 1: # Check if the cluster has one member (no overlap)
			split_variant_line = variant_line[0].split()

			if caller == "pbsv" or caller == "sniffles":
				new_bed_line = split_variant_line[0] + "\t" + split_variant_line[1] + "\t" + split_variant_line[2] + "\t" + split_variant_line[4]
			else:
				new_bed_line = split_variant_line[0] + "\t" + split_variant_line[1] + "\t" + split_variant_line[2] + "\t" + split_variant_line[3]
			bed_lines.append(new_bed_line)

		elif len(variant_line) > 1: # Check if cluster has multiple overlapping calls
			best_supported_call = resolve_cluster(variant_line,caller) # Select one call from cluster.
			best_supported_call_split = best_supported_call.split()
			if caller == "pbsv" or caller == "sniffles":
				new_bed_line = best_supported_call_split[0] + "\t" + best_supported_call_split[1] + "\t" + best_supported_call_split[2] + "\t" + best_supported_call_split[4]
			else:
				new_bed_line = best_supported_call_split[0] + "\t" + best_supported_call_split[1] + "\t" + best_supported_call_split[2] + "\t" + best_supported_call_split[3]
			bed_lines.append(new_bed_line)
	return(bed_lines)

def write_bed(bedlines):
	bed_dir = os.path.dirname(args.input_bed)
	bed_dir = bed_dir.replace("1_includes_overlap", "2_variant_calls_declustered")
	sample_name = os.path.basename(args.input_bed).split(".")[0]

	output_file = bed_dir + "/" + sample_name + ".declustered.bed"

	# Check if output directories exist.
	if not os.path.exists(bed_dir):
		os.makedirs(bed_dir)

	#Check if files exist. If not, write to file.
	if os.path.isfile(output_file):
		print(str(output_file) + " exists. Not overwriting.")
	else:
		#print("Creating: " +str(output_file))
		with open(output_file, 'w', newline='\n') as f:
				f.writelines("%s\n" % l for l in bedlines)

if args.sv_caller.lower() == "pbsv":
	with open(args.input_bed) as f:
		variants = f.readlines()
	pbsv_cluster_dict = get_clusters(variants, "pbsv")
	pbsv_bedlines = get_calls(pbsv_cluster_dict, "pbsv")
	write_bed(pbsv_bedlines)

elif args.sv_caller.lower() == "sniffles":
	with open(args.input_bed) as f:
		variants = f.readlines()
	sniffles_cluster_dict = get_clusters(variants, "sniffles")
	sniffles_bedlines = get_calls(sniffles_cluster_dict, "sniffles")
	write_bed(sniffles_bedlines)

elif args.sv_caller.lower() == "svim":
	with open(args.input_bed) as f:
		variants = f.readlines()
	svim_cluster_dict = get_clusters(variants, "svim")
	svim_bedlines = get_calls(svim_cluster_dict, "svim")
	write_bed(svim_bedlines)

elif args.sv_caller.lower() == "assemblytics" or args.sv_caller.lower() == "mumandco":
	with open(args.input_bed) as f:
		variants = f.readlines()
	assembly_cluster_dict = get_clusters(variants, "assembly")
	assembly_bedlines = get_calls(assembly_cluster_dict, "assembly")
	write_bed(assembly_bedlines)

elif args.sv_caller.lower() == "fusorsv":
	with open(args.input_bed) as f:
		variants = f.readlines()
	fusorsv_cluster_dict = get_clusters(variants, "fusorsv")
	fusorsv_bedlines = get_calls(fusorsv_cluster_dict, "fusorsv")
	write_bed(fusorsv_bedlines)

else:
	print("Caller not supported for: " + args.sv_caller)
