import argparse
import os
from collections import defaultdict
import random

parser = argparse.ArgumentParser()
parser.add_argument("input_bed", help="bed file with clustered reads. Created from a matching vcf file.")
parser.add_argument("sv_caller", help="variant caller used to create vcf file. Use pbsv, sniffles, or svim")
args = parser.parse_args()

# Get clusters (generated by bedtools) and store them in a dict
def get_clusters(variants,caller):
	cluster_dict = defaultdict(list)

	if caller == "sniffles" or caller == "pbsv":
		for line in variants:
			line_split = line.split()
			cluster_number = line_split[6]
			cluster_dict[cluster_number].append(line)

	else: # Process SVIM
		for line in variants:
			line_split = line.split()
			cluster_number = line_split[5]
			cluster_dict[cluster_number].append(line)

	return(cluster_dict)

# Separate variant call dict into sv call clusters with one member or multiple members
def resolve_cluster(sv_calls,caller):
	best_support_value = 0 # Store the value for the best supported sv call. Metric depends on caller.
	best_supported_call = 0 # Stores the highest support call from the sv calls list.
	best_support_value_tied = False
	current_call = 0
	tied_calls = set() # Calls sometimes have the same value for the support metric used. A set of tied calls is created to randomly select a call from if tied.

	if caller == "pbsv":
		precise_call = False

		for line in sv_calls:
			cnv_call = False
			sv_call_split = line.split("\t")
			call_precision = sv_call_split[3]
			call_name = sv_call_split[4]

			if "CNV" in call_name:
				cnv_call = True

			sv_name = sv_call_split[4]
			if precise_call == False and call_precision == "PRECISE":
				# cnv calls don't give read support
				if not cnv_call:
					sv_read_support = sv_call_split[5].split(":")[1]
					sv_read_support = sv_read_support.split(",")[1]
					sv_read_support = int(sv_read_support)
					best_support_value = sv_read_support

				precise_call = True
				best_support_value_tied = False
				tied_calls = set()
				best_supported_call = current_call

			elif precise_call == True and call_precision == "PRECISE":
				# Check if variant type is a CNV. pbsv doesn't give any support data to choose the best supported cnv call when there is overlap.
				if "CNV" in sv_name:
					best_support_value_tied = True
					tied_calls.add(best_supported_call)
					tied_calls.add(current_call)

				else:
					# I'm using the AD entry reported by pbsv. It's reported as 2 comma separated numbers. The 1st is the ref allele depth, the 2nd is the number of reads supporting the sv
					sv_read_support = sv_call_split[5].split(":")[1]
					sv_read_support = sv_read_support.split(",")[1]
					sv_read_support = int(sv_read_support)

					if sv_read_support == best_support_value:
						best_support_value_tied = True
						tied_calls.add(best_supported_call)
						tied_calls.add(current_call)

					elif sv_read_support > best_support_value:
						tied_calls = set()
						best_support_value_tied = False
						best_support_value = sv_read_support
						best_supported_call = current_call

			else:

				# Check if variant type is a CNV. pbsv doesn't give any support data to choose the best supported cnv call when there is overlap.
				if "CNV" in sv_name:
					best_support_value_tied = True
					tied_calls.add(best_supported_call)
					tied_calls.add(current_call)

				else:
					# I'm using the AD entry reported by pbsv. It's reported as 2 comma separated numbers. The 1st is the ref allele depth, the 2nd is the number of reads supporting the sv
					sv_read_support = sv_call_split[5].split(":")[1]
					sv_read_support = sv_read_support.split(",")[1]
					sv_read_support = int(sv_read_support)

					if sv_read_support == best_support_value:
						best_support_value_tied = True
						tied_calls.add(best_supported_call)
						tied_calls.add(current_call)
					elif sv_read_support > best_support_value:
						tied_calls = set()
						best_support_value_tied = False
						best_support_value = sv_read_support
						best_supported_call = current_call

			current_call += 1

		# If multiple calls have the best support value, chose one randonly
		if best_support_value_tied:
			random_line = random.sample(list(tied_calls),1)
			best_call_line = sv_calls[random_line[0]]

		else:
			best_call_line = sv_calls[best_supported_call]

	elif caller == "sniffles":
		precise_call = False
		for line in sv_calls:

			sv_call_split = line.split("\t")
			call_precision = sv_call_split[3]
			# I'm using the sniffles DV value, which is the number of reads supporting the variant
			sv_read_support = sv_call_split[5].split(":")[3]
			sv_read_support = int(sv_read_support)

			# Precise calls are selected over imprecise calls
			if precise_call == False and call_precision == "PRECISE":
				precise_call = True
				best_support_value_tied = False
				tied_calls = set()
				best_support_value = sv_read_support
				best_supported_call = current_call

			elif precise_call == True and call_precision == "PRECISE":
				if sv_read_support == best_support_value:
					best_support_value_tied = True
					tied_calls.add(best_supported_call)
					tied_calls.add(current_call)

				elif sv_read_support > best_support_value:
					tied_calls = set()
					best_support_value_tied = False
					best_support_value = sv_read_support
					best_supported_call = current_call


			else:
				if sv_read_support == best_support_value:
					best_support_value_tied = True
					tied_calls.add(best_supported_call)
					tied_calls.add(current_call)

				elif sv_read_support > best_support_value:
					tied_calls = set()
					best_support_value_tied = False
					best_support_value = sv_read_support
					best_supported_call = current_call
			current_call += 1

		if best_support_value_tied:
			random_line = random.sample(list(tied_calls),1)
			best_call_line = sv_calls[random_line[0]]
		else:
			best_call_line = sv_calls[best_supported_call]

	elif caller == "svim":
		for line in sv_calls:
			sv_call_split = line.split("\t")

			# I'm using the svim QUAL value. This is calculated by svim
			sv_read_support = sv_call_split[4].split(":")[1]
			sv_read_support = int(sv_read_support)

			if sv_read_support == best_support_value:
				best_support_value_tied = True
				tied_calls.add(best_supported_call)
				tied_calls.add(current_call)

			elif sv_read_support > best_support_value:
				tied_calls = set()
				best_support_value_tied = False
				best_support_value = sv_read_support
				best_supported_call = current_call
			current_call += 1

		if best_support_value_tied:
			random_line = random.sample(list(tied_calls),1)
			best_call_line = sv_calls[random_line[0]]

		else:
			best_call_line = sv_calls[best_supported_call]

	return(best_call_line)

# Take the clustered call dict and return the bedfile lines to write to disk
def get_calls(cluster_dict,caller):
	bed_lines = []
	total_discarded_lines = 0
	for cluster_number, variant_line in cluster_dict.items():
		if len(variant_line) == 1: # Check if the cluster has one member (no overlap)
			split_variant_line = variant_line[0].split()

			if caller == "pbsv" or caller == "sniffles":
				new_bed_line = split_variant_line[0] + "\t" + split_variant_line[1] + "\t" + split_variant_line[2] + "\t" + split_variant_line[4]
			else:
				new_bed_line = split_variant_line[0] + "\t" + split_variant_line[1] + "\t" + split_variant_line[2] + "\t" + split_variant_line[3]
			bed_lines.append(new_bed_line)

		elif len(variant_line) > 1: # Check if cluster has multiple overlapping calls
			discarded_lines = len(variant_line) - 1
			total_discarded_lines = total_discarded_lines + discarded_lines
			best_supported_call = resolve_cluster(variant_line,caller) # Select one call from cluster.
			best_supported_call_split = best_supported_call.split()
			if caller == "pbsv" or caller == "sniffles":
				new_bed_line = best_supported_call_split[0] + "\t" + best_supported_call_split[1] + "\t" + best_supported_call_split[2] + "\t" + best_supported_call_split[4]
			else:
				new_bed_line = best_supported_call_split[0] + "\t" + best_supported_call_split[1] + "\t" + best_supported_call_split[2] + "\t" + best_supported_call_split[3]
			bed_lines.append(new_bed_line)
	return(bed_lines,total_discarded_lines)

# Write to disk
def write_bed(bedlines):
	bed_dir = os.path.dirname(args.input_bed)
	sample_name = os.path.basename(args.input_bed).split(".")[0]

	output_file = bed_dir + "/" + sample_name + ".declustered.bed"

	# Check if output directories exist.
	if not os.path.exists(bed_dir):
		os.makedirs(bed_dir)

	#Check if files exist. If not, write to file.
	if os.path.isfile(output_file):
		print(str(output_file) + " exists. Not overwriting.")
	else:
		with open(output_file, 'w', newline='\n') as f:
				f.writelines("%s\n" % l for l in bedlines)

# Write summary statistics to disk
def write_stats(bedlines, discarded_count):
	bed_dir = os.path.dirname(args.input_bed)
	sample_name = os.path.basename(args.input_bed).split(".")[0]
	output_file = bed_dir + "/" + sample_name + ".statistics.txt"

	total_calls = len(bedlines)
	final_calls = total_calls - discarded_count

	# Check if output directories exist.
	if not os.path.exists(bed_dir):
		os.makedirs(bed_dir)

	#Check if files exist. If not, write to file.
	if os.path.isfile(output_file):
		print(str(output_file) + " exists. Not overwriting.")
	else:
		with open(output_file, 'w', newline='\n') as f:
				f.write("Total sv calls: " + str(total_calls) + "\n")
				f.write("Discarded calls due to overlap: " + str(discarded_count) + "\n")
				f.write("Final calls: " + str(final_calls) + "\n")

if args.sv_caller.lower() == "pbsv":
	with open(args.input_bed) as f:
		variants = f.readlines()
	pbsv_cluster_dict = get_clusters(variants, "pbsv")
	pbsv_bedlines = get_calls(pbsv_cluster_dict, "pbsv")
	write_bed(pbsv_bedlines[0])
	write_stats(pbsv_bedlines[0], pbsv_bedlines[1])

elif args.sv_caller.lower() == "sniffles":
	with open(args.input_bed) as f:
		variants = f.readlines()
	sniffles_cluster_dict = get_clusters(variants, "sniffles")
	sniffles_bedlines = get_calls(sniffles_cluster_dict, "sniffles")
	write_bed(sniffles_bedlines[0])
	write_stats(sniffles_bedlines[0], sniffles_bedlines[1])

elif args.sv_caller.lower() == "svim":
	with open(args.input_bed) as f:
		variants = f.readlines()
	svim_cluster_dict = get_clusters(variants, "svim")
	svim_bedlines = get_calls(svim_cluster_dict, "svim")
	write_bed(svim_bedlines[0])
	write_stats(svim_bedlines[0], svim_bedlines[1])

else:
	print("Caller not supported for: " + args.sv_caller)
