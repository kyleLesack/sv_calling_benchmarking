import argparse
import os
from collections import defaultdict
import random

parser = argparse.ArgumentParser()
parser.add_argument("input_bed", help="bed file with clustered reads. Created from a matching vcf file.")
parser.add_argument("sv_caller", help="variant caller used to create vcf file. Use breakdancer, cnmops, cnvnator, delly, hydra, lumpy, or fusorsv.")
args = parser.parse_args()

# Get clusters (generated by bedtools) and store them in a dict
def get_clusters(variants,caller):
	cluster_dict = defaultdict(list)

	if caller == "fusorsv" or caller == "hydra":
		for line in variants:
			line_split = line.split()
			cluster_number = line_split[4]
			cluster_dict[cluster_number].append(line)

	elif caller == "delly" or caller == "breakdancer" or caller == "lumpy" or caller == "cnmops" or caller == "cnvnator":
		for line in variants:
			line_split = line.split()
			cluster_number = line_split[5]
			cluster_dict[cluster_number].append(line)

	return(cluster_dict)

# Separate variant call dict into sv call clusters with one member or multiple members
def resolve_cluster(sv_calls,caller):
	best_support_value = 0 # Store the value for the best supported sv call. Metric depends on caller.
	best_supported_call = 0 # Stores the highest support call from the sv calls list.
	best_support_value_tied = False
	current_call = 0
	tied_calls = set() # Calls sometimes have the same value for the support metric used. A set of tied calls is created to randomly select a call from if tied.

	if caller == "delly" or caller == "breakdancer" or caller == "lumpy" or caller == "cnmops":
		for line in sv_calls:
			sv_call_split = line.split("\t")

			sv_support = sv_call_split[4].split(":")[1]
			sv_support = int(sv_support)

			if sv_support == best_support_value:
				best_support_value_tied = True
				tied_calls.add(best_supported_call)
				tied_calls.add(current_call)

			elif sv_support > best_support_value:
				tied_calls = set()
				best_support_value_tied = False
				best_support_value = sv_support
				best_supported_call = current_call
			current_call += 1

		if best_support_value_tied:
			random_line = random.sample(list(tied_calls),1)
			best_call_line = sv_calls[random_line[0]]

		else:
			best_call_line = sv_calls[best_supported_call]

	elif caller == "cnvnator":
		for line in sv_calls:
			sv_call_split = line.split("\t")
			sv_support = sv_call_split[4].split(":")[1]
			sv_support = float(sv_support)

			if sv_support == best_support_value:
				best_support_value_tied = True
				tied_calls.add(best_supported_call)
				tied_calls.add(current_call)

			elif sv_support < best_support_value: # cnvnator uses e-values, so choose the lowest
				tied_calls = set()
				best_support_value_tied = False
				best_support_value = sv_support
				best_supported_call = current_call
			current_call += 1

		if best_support_value_tied:
			random_line = random.sample(list(tied_calls),1)
			best_call_line = sv_calls[random_line[0]]

		else:
			best_call_line = sv_calls[best_supported_call]


	elif caller == "fusorsv" or caller == "hydra":
		for line in sv_calls:
			best_call_line = random.sample(sv_calls,1)[0]

	return(best_call_line)

# Take the clustered call dict and return the bedfile lines to write to disk
def get_calls(cluster_dict,caller):
	bed_lines = []
	for cluster_number, variant_line in cluster_dict.items():
		if len(variant_line) == 1: # Check if the cluster has one member (no overlap)
			split_variant_line = variant_line[0].split()
			new_bed_line = split_variant_line[0] + "\t" + split_variant_line[1] + "\t" + split_variant_line[2] + "\t" + split_variant_line[3]
			bed_lines.append(new_bed_line)

		elif len(variant_line) > 1: # Check if cluster has multiple overlapping calls
			best_supported_call = resolve_cluster(variant_line,caller) # Select one call from cluster.
			best_supported_call_split = best_supported_call.split()
			new_bed_line = best_supported_call_split[0] + "\t" + best_supported_call_split[1] + "\t" + best_supported_call_split[2] + "\t" + best_supported_call_split[3]
			bed_lines.append(new_bed_line)
	return(bed_lines)

def write_bed(bedlines):
	bed_dir = os.path.dirname(args.input_bed)
	bed_dir = bed_dir.replace("1_includes_overlap", "2_variant_calls_declustered")
	sample_name = os.path.basename(args.input_bed).split(".")[0]

	output_file = bed_dir + "/" + sample_name + ".declustered.bed"

	# Check if output directories exist.
	if not os.path.exists(bed_dir):
		os.makedirs(bed_dir)

	#Check if files exist. If not, write to file.
	if os.path.isfile(output_file):
		print(str(output_file) + " exists. Not overwriting.")
	else:
		with open(output_file, 'w', newline='\n') as f:
				f.writelines("%s\n" % l for l in bedlines)

if args.sv_caller.lower() == "delly":
	with open(args.input_bed) as f:
		variants = f.readlines()
	delly_cluster_dict = get_clusters(variants, "delly")
	delly_bedlines = get_calls(delly_cluster_dict, "delly")
	write_bed(delly_bedlines)

elif args.sv_caller.lower() == "breakdancer":
	with open(args.input_bed) as f:
		variants = f.readlines()
	breakdancer_cluster_dict = get_clusters(variants, "breakdancer")
	breakdancer_bedlines = get_calls(breakdancer_cluster_dict, "breakdancer")
	write_bed(breakdancer_bedlines)

elif args.sv_caller.lower() == "lumpy":
	with open(args.input_bed) as f:
		variants = f.readlines()
	lumpy_cluster_dict = get_clusters(variants, "lumpy")
	lumpy_bedlines = get_calls(lumpy_cluster_dict, "lumpy")
	write_bed(lumpy_bedlines)

elif args.sv_caller.lower() == "hydra":
	with open(args.input_bed) as f:
		variants = f.readlines()
	hydra_cluster_dict = get_clusters(variants, "hydra")
	hydra_bedlines = get_calls(hydra_cluster_dict, "hydra")
	write_bed(hydra_bedlines)

elif args.sv_caller.lower() == "cnmops":
	with open(args.input_bed) as f:
		variants = f.readlines()
	cnmops_cluster_dict = get_clusters(variants, "cnmops")
	cnmops_bedlines = get_calls(cnmops_cluster_dict, "cnmops")
	write_bed(cnmops_bedlines)

elif args.sv_caller.lower() == "cnvnator":
	with open(args.input_bed) as f:
		variants = f.readlines()
	cnvnator_cluster_dict = get_clusters(variants, "cnvnator")
	cnvnator_bedlines = get_calls(cnvnator_cluster_dict, "cnvnator")
	write_bed(cnvnator_bedlines)

elif args.sv_caller.lower() == "fusorsv":
	with open(args.input_bed) as f:
		variants = f.readlines()
	fusorsv_cluster_dict = get_clusters(variants, "fusorsv")
	fusorsv_bedlines = get_calls(fusorsv_cluster_dict, "fusorsv")
	write_bed(fusorsv_bedlines)


else:
	print("Caller not supported for: " + args.sv_caller)
